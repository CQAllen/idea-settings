<application>
  <component name="AppStorage">
    <histories>
      <item value="大于" />
      <item value="小于" />
      <item value="小宇" />
      <item value="lt" />
      <item value="compare" />
      <item value="审核" />
      <item value="待审核" />
      <item value="policy" />
      <item value="fetching" />
      <item value="* Thread that finalizes referents. All references should implement {@code * com.google.common.base.FinalizableReference}. * * &lt;p&gt;While this class is public, we consider it to be *internal* and not part of our published API. * It is public so we can access it reflectively across class loaders in secure environments. * * &lt;p&gt;This class can't depend on other Guava code. If we were to load this class in the same class * loader as the rest of Guava, this thread would keep an indirect strong reference to the class * loader and prevent it from being garbage collected. This poses a problem for environments where * you want to throw away the class loader. For example, dynamically reloading a web application or * unloading an OSGi bundle. * * &lt;p&gt;{@code com.google.common.base.FinalizableReferenceQueue} loads this class in its own class * loader. That way, this class doesn't prevent the main class loader from getting garbage * collected, and this class can detect when the main class loader has been garbage collected and * stop itself." />
      <item value="collected, and this class can detect when the main class loader has been garbage collected and" />
      <item value="stop itself." />
      <item value="Thread that finalizes referents. All references should implement {@code * com.google.common.base.FinalizableReference}. * * &lt;p&gt;While this class is public, we consider it to be *internal* and not part of our published API. * It is public so we can access it reflectively across class loaders in secure environments. * * &lt;p&gt;This class can't depend on other Guava code. If we were to load this class in the same class * loader as the rest of Guava, this thread would keep an indirect strong reference to the class * loader and prevent it from being garbage collected. This poses a problem for environments where * you want to throw away the class loader. For example, dynamically reloading a web application or * unloading an OSGi bundle. * * &lt;p&gt;{@code com.google.common.base.FinalizableReferenceQueue} loads this class in its own class * loader. That way, this class doesn't prevent the main class loader from getting garbage * collected, and this class can detect when the main class loader has been garbage collected and * stop itself." />
      <item value="Component" />
      <item value="组件" />
      <item value="个人" />
      <item value="Sneaky" />
      <item value="替换" />
      <item value="filer" />
      <item value="meta" />
      <item value="业主" />
      <item value="isdone" />
      <item value="filter" />
      <item value="identity" />
      <item value="Optional" />
      <item value="dependency" />
      <item value="循环" />
      <item value="新环保" />
      <item value="Finalizer" />
      <item value="internal" />
      <item value="tile" />
      <item value="vola" />
      <item value="volatile" />
      <item value="volitile" />
      <item value="semaphore" />
      <item value="phore" />
      <item value="sema" />
      <item value="sea" />
      <item value="seamphore" />
      <item value="Latch" />
      <item value="countDownLatch" />
      <item value="purge" />
      <item value="CAS" />
      <item value="Phantom" />
      <item value="Reentrant" />
      <item value="Semaphore" />
      <item value="ReentrantLock" />
      <item value="AtomicLong" />
      <item value="软弱" />
      <item value="weak" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="46" />
        <entry key="ENGLISH" value="47" />
        <entry key="CHINESE_TRADITIONAL" value="2" />
      </map>
    </option>
  </component>
</application>