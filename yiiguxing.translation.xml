<application>
  <component name="AppStorage">
    <histories>
      <item value="* Performs the given action for each remaining element until all elements * have been processed or the action throws an exception. Actions are * performed in the order of iteration, if that order is specified. * Exceptions thrown by the action are relayed to the caller. * &lt;p&gt; * The behavior of an iterator is unspecified if the action modifies the * collection in any way (even by calling the {@link #remove remove} method * or other mutator methods of {@code Iterator} subtypes), * unless an overriding class has specified a concurrent modification policy. * &lt;p&gt; * Subsequent behavior of an iterator is unspecified if the action throws an * exception." />
      <item value="Removes from the underlying collection the last element returned by this iterator (optional operation). This method can be called only once per call to {@link #next}. &lt;p&gt; The behavior of an iterator is unspecified if the underlying collection is modified while the iteration is in progress in any way other than by calling this method, unless an overriding class has specified a concurrent modification policy. &lt;p&gt; The behavior of an iterator is unspecified if this method is called after a call to the {@link #forEachRemaining forEachRemaining} method." />
      <item value="Removes from the underlying collection the last element returned by this iterator (optional operation). This method can be called only once per call to {@link #next}. &lt;p&gt; The behavior of an iterator is unspecified if the underlying collection is modified while the iteration is in progress in any way other than by calling this method, unless an overriding class has specified a concurrent modification policy. &lt;p&gt; The behavior of an iterator is unspecified if this method is called after a call to the {@link #forEachRemaining forEachRemaining} method. @implSpec The default implementation throws an instance of {@link UnsupportedOperationException} and performs no other action. @throws UnsupportedOperationException if the {@code remove} operation is not supported by this iterator @throws IllegalStateException if the {@code next} method has not yet been called, or the {@code remove} method has already been called after the last call to the {@code next}" />
      <item value="Circuit Breaker" />
      <item value="Features" />
      <item value="distributed" />
      <item value="tracing" />
      <item value="tra" />
      <item value="distr" />
      <item value="registry" />
      <item value="regist" />
      <item value="hierarchical-multi-select" />
      <item value="listener" />
      <item value="gateway" />
      <item value="Micro" />
      <item value="Microservice" />
      <item value="微服务" />
      <item value="Equals" />
      <item value="Equal" />
      <item value="大于等于" />
      <item value="等于" />
      <item value="大于" />
      <item value="小于" />
      <item value="小宇" />
      <item value="lt" />
      <item value="compare" />
      <item value="审核" />
      <item value="待审核" />
      <item value="policy" />
      <item value="fetching" />
      <item value="* Thread that finalizes referents. All references should implement {@code * com.google.common.base.FinalizableReference}. * * &lt;p&gt;While this class is public, we consider it to be *internal* and not part of our published API. * It is public so we can access it reflectively across class loaders in secure environments. * * &lt;p&gt;This class can't depend on other Guava code. If we were to load this class in the same class * loader as the rest of Guava, this thread would keep an indirect strong reference to the class * loader and prevent it from being garbage collected. This poses a problem for environments where * you want to throw away the class loader. For example, dynamically reloading a web application or * unloading an OSGi bundle. * * &lt;p&gt;{@code com.google.common.base.FinalizableReferenceQueue} loads this class in its own class * loader. That way, this class doesn't prevent the main class loader from getting garbage * collected, and this class can detect when the main class loader has been garbage collected and * stop itself." />
      <item value="collected, and this class can detect when the main class loader has been garbage collected and" />
      <item value="stop itself." />
      <item value="Thread that finalizes referents. All references should implement {@code * com.google.common.base.FinalizableReference}. * * &lt;p&gt;While this class is public, we consider it to be *internal* and not part of our published API. * It is public so we can access it reflectively across class loaders in secure environments. * * &lt;p&gt;This class can't depend on other Guava code. If we were to load this class in the same class * loader as the rest of Guava, this thread would keep an indirect strong reference to the class * loader and prevent it from being garbage collected. This poses a problem for environments where * you want to throw away the class loader. For example, dynamically reloading a web application or * unloading an OSGi bundle. * * &lt;p&gt;{@code com.google.common.base.FinalizableReferenceQueue} loads this class in its own class * loader. That way, this class doesn't prevent the main class loader from getting garbage * collected, and this class can detect when the main class loader has been garbage collected and * stop itself." />
      <item value="Component" />
      <item value="组件" />
      <item value="个人" />
      <item value="Sneaky" />
      <item value="替换" />
      <item value="filer" />
      <item value="meta" />
      <item value="业主" />
      <item value="isdone" />
      <item value="filter" />
      <item value="identity" />
      <item value="Optional" />
      <item value="dependency" />
      <item value="循环" />
      <item value="新环保" />
      <item value="Finalizer" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="53" />
        <entry key="ENGLISH" value="54" />
        <entry key="CHINESE_TRADITIONAL" value="2" />
      </map>
    </option>
  </component>
</application>